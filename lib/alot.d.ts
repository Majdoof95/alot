// Generated by dts-bundle v0.7.3

declare module 'alot' {
    import { Alot as AlotInner } from 'alot/alot';
    import { AlotMeta } from 'alot/AlotMeta';
    interface IAlotConstructor {
        new <T>(array: T[], meta?: AlotMeta): AlotInner<T>;
        <T>(array: T[], meta?: AlotMeta): AlotInner<T>;
    }
    export class Alot<T> extends AlotInner<T> {
        static default: IAlotConstructor;
    }
    const _default: IAlotConstructor;
    export default _default;
}

declare module 'alot/alot' {
    import './streams/FilterStream';
    import './streams/MapStream';
    import './streams/SkipStream';
    import './streams/TakeStream';
    import './streams/GroupStream';
    import { AlotMeta } from 'alot/AlotMeta';
    import { AlotProto } from 'alot/AlotProto';
    import { IAlotStream, AlotStreamIterationResult } from 'alot/streams/IAlotStream';
    export class Alot<T = any> extends AlotProto<T> {
        array: T[];
        meta?: AlotMeta;
        constructor(array: T[], meta?: AlotMeta);
    }
    export class ArrayStream<T> implements IAlotStream<T> {
        array: T[];
        isAsync: boolean;
        constructor(array: T[]);
        next(): AlotStreamIterationResult<T>;
        nextAsync(): Promise<AlotStreamIterationResult<T>>;
        reset(): this;
    }
}

declare module 'alot/AlotMeta' {
    export interface AlotStreamOpts {
        async?: boolean;
    }
    export interface AlotMeta {
    }
    export interface AlotMetaAsync extends AlotMeta {
        threads?: number;
    }
}

declare module 'alot/AlotProto' {
    import { FilterStream, FilterStreamAsync } from 'alot/streams/FilterStream';
    import { MapStream, MapManyStream, MethodMap, MethodMapMany } from 'alot/streams/MapStream';
    import { TakeStream, TakeWhileStream, TakeWhileMethod } from 'alot/streams/TakeStream';
    import { SkipStream, SkipWhileMethod, SkipWhileStream } from 'alot/streams/SkipStream';
    import { MethodFilter } from 'alot/Methods';
    import { IAlotStream, AlotStreamIterationResult } from "alot/streams/IAlotStream";
    import { AlotMeta, AlotMetaAsync } from 'alot/AlotMeta';
    import { GroupByKeyFn, GroupByStream } from 'alot/streams/GroupStream';
    import { DistinctByKeyFn, DistinctByStream } from 'alot/streams/DistinctStream';
    export class AlotProto<T, TSource = T> implements IAlotStream<T> {
        stream: IAlotStream<TSource>;
        isAsync: boolean;
        constructor(stream: IAlotStream<TSource>);
        next(): AlotStreamIterationResult<T>;
        nextAsync(): Promise<AlotStreamIterationResult<T>>;
        reset(): this;
        filter(fn: MethodFilter<T>): FilterStream<T>;
        filterAsync(fn: MethodFilter<T>): FilterStreamAsync<T>;
        map<TResult>(fn: MethodMap<T, TResult>): MapStream<T, TResult>;
        mapAsync<TResult>(fn: MethodMap<T, TResult>, meta?: AlotMeta): MapStream<T, TResult>;
        mapMany<TResult>(fn: MethodMapMany<T, TResult>): MapManyStream<T, TResult>;
        mapManyAsync<TResult>(fn: MethodMapMany<T, TResult>): MapManyStream<T, TResult>;
        take(count: number): TakeStream<T>;
        takeWhile(fn: TakeWhileMethod<T>): TakeWhileStream<T>;
        skip(count: number): SkipStream<T>;
        skipWhile(fn: SkipWhileMethod<T>): SkipWhileStream<T>;
        groupBy<TValue = any, TKey = string>(fn: GroupByKeyFn<T, TKey>): GroupByStream<T, TKey, TValue>;
        distinctBy(fn: DistinctByKeyFn<T>): DistinctByStream<T, string>;
        forEach(fn: (x: T, index?: number) => void): void;
        toDictionary(keyFn: (x: T) => string | any, valFn?: (x: T) => any): {
            [key: string]: T;
        };
        toDictionaryAsync(keyFn: (x: T) => string | Promise<string> | any, valFn?: (x: T) => Promise<any> | any): Promise<{
            [key: string]: T;
        }>;
        toArray(): T[];
        toArrayAsync(meta?: AlotMetaAsync): PromiseLike<T[]>;
        first(): T;
    }
}

declare module 'alot/streams/IAlotStream' {
    export interface IAlotStream<T = any> {
        reset(): this;
        next(): AlotStreamIterationResult<T>;
        nextAsync(): Promise<AlotStreamIterationResult<T>>;
        isAsync: boolean;
    }
    export interface AlotStreamIterationResult<T> {
        value: T;
        done: boolean;
        index?: number;
    }
}

declare module 'alot/streams/FilterStream' {
    import { IAlotStream } from "alot/streams/IAlotStream";
    import { AlotProto } from "alot/AlotProto";
    import { MethodFilter } from 'alot/Methods';
    import { AlotMetaAsync } from 'alot/AlotMeta';
    export class FilterStream<T> extends AlotProto<T> {
        stream: IAlotStream<T>;
        fn: MethodFilter<T>;
        constructor(stream: IAlotStream<T>, fn: MethodFilter<T>);
        next(): import("./IAlotStream").AlotStreamIterationResult<T>;
    }
    export class FilterStreamAsync<T> extends AlotProto<T> {
        stream: IAlotStream<T>;
        fn: MethodFilter<T>;
        isAsync: boolean;
        constructor(stream: IAlotStream<T>, fn: MethodFilter<T>);
        nextAsync(): Promise<import("./IAlotStream").AlotStreamIterationResult<T>>;
        reset(): this;
        toArrayAsync(meta?: AlotMetaAsync): Promise<T[]>;
    }
}

declare module 'alot/streams/MapStream' {
    import { IAlotStream } from "alot/streams/IAlotStream";
    import { AlotProto } from "alot/AlotProto";
    import { AlotStreamOpts } from 'alot/AlotMeta';
    export interface MethodMap<T, TResult> {
        (x: T, i?: number): TResult | PromiseLike<TResult>;
    }
    export class MapStream<TSource, TResult> extends AlotProto<TResult, TSource> {
        stream: IAlotStream<TSource>;
        fn: MethodMap<TSource, TResult>;
        constructor(stream: IAlotStream<TSource>, fn: MethodMap<TSource, TResult>, opts?: AlotStreamOpts);
        next(): any;
        nextAsync(): Promise<{
            value: TResult;
            done: boolean;
        }>;
    }
    export interface MethodMapMany<T, TResult> {
        (x: T, i?: number): TResult[] | PromiseLike<TResult[]>;
    }
    export class MapManyStream<T, TResult> extends AlotProto<TResult, T> {
        stream: IAlotStream<T>;
        fn: MethodMapMany<T, TResult>;
        opts?: AlotStreamOpts;
        constructor(stream: IAlotStream<T>, fn: MethodMapMany<T, TResult>, opts?: AlotStreamOpts);
        next(): any;
        nextAsync(): any;
        reset(): this;
    }
}

declare module 'alot/streams/TakeStream' {
    import { IAlotStream } from 'alot/streams/IAlotStream';
    import { AlotProto } from "alot/AlotProto";
    export class TakeStream<T> extends AlotProto<T> {
        stream: IAlotStream<T>;
        count: number;
        constructor(stream: IAlotStream<T>, count: number);
        next(): import("./IAlotStream").AlotStreamIterationResult<T>;
        reset(): this;
    }
    export interface TakeWhileMethod<T> {
        (x: T): boolean;
    }
    export class TakeWhileStream<T> extends AlotProto<T> {
        stream: IAlotStream<T>;
        fn: TakeWhileMethod<T>;
        constructor(stream: IAlotStream<T>, fn: TakeWhileMethod<T>);
        next(): any;
        reset(): this;
    }
}

declare module 'alot/streams/SkipStream' {
    import { IAlotStream } from "alot/streams/IAlotStream";
    import { AlotProto } from "alot/AlotProto";
    export class SkipStream<T> extends AlotProto<T> {
        stream: IAlotStream<T>;
        count: number;
        constructor(stream: IAlotStream<T>, count: number);
        next(): import("./IAlotStream").AlotStreamIterationResult<T>;
        reset(): this;
    }
    export interface SkipWhileMethod<T> {
        (x: T): boolean;
    }
    export class SkipWhileStream<T> extends AlotProto<T> {
        stream: IAlotStream<T>;
        fn: SkipWhileMethod<T>;
        constructor(stream: IAlotStream<T>, fn: SkipWhileMethod<T>);
        next(): import("./IAlotStream").AlotStreamIterationResult<T>;
        reset(): this;
    }
}

declare module 'alot/Methods' {
    export interface MethodFilter<T> {
        (x: T, i?: number): boolean | Promise<boolean>;
    }
}

declare module 'alot/streams/GroupStream' {
    import { IAlotStream } from "alot/streams/IAlotStream";
    import { AlotProto } from "alot/AlotProto";
    export interface GroupByKeyFn<T, TKey = string> {
        (x: T, i?: number): TKey;
    }
    export class GroupByStream<T, TKey, TValue> extends AlotProto<T> {
        stream: IAlotStream<T>;
        fn: GroupByKeyFn<T, TKey>;
        constructor(stream: IAlotStream<T>, fn: GroupByKeyFn<T, TKey>);
        next(): any;
    }
}

declare module 'alot/streams/DistinctStream' {
    import { IAlotStream } from "alot/streams/IAlotStream";
    import { AlotProto } from "alot/AlotProto";
    export interface DistinctByKeyFn<T, TKey = string> {
        (x: T, i?: number): TKey;
    }
    export class DistinctByStream<T, TKey = string | number> extends AlotProto<T> {
        stream: IAlotStream<T>;
        fn: DistinctByKeyFn<T, TKey>;
        constructor(stream: IAlotStream<T>, fn: DistinctByKeyFn<T, TKey>);
        next(): import("./IAlotStream").AlotStreamIterationResult<T>;
        reset(): this;
    }
}

